\section{Plans}
\subsection{Explain the subsumption architecture!}
\begin{itemize}
	\item Ziel: Spezifikation von Agentenverhalten ohne Symbolische Repräsentation der Umwelt
	\item Verhalten wird direkt von den Zustand auf eine Aktion
	\item Zustand entsteht durch die Verarbeitung der Beobachtungen
	\item Direkte Koppelung zwischen Zustände und Aktionen
	\item Verhalten ist mehrschichtig d.h. es gibt verschiedene Ebenen welche jeweils einen kleinen Teil des Verhaltens spezifiziert
	\item jedes Verhalten hat eine priorität, je geringer die Ebene desto höher die Priorität
	\item Algorithmus:
	\begin{itemize}
		\item Beobachte Umwelt
		\item ermittle aller möglichen Aktionen
		\item führe die Aktion mit der höchsten Priorität aus
	\end{itemize}
\end{itemize}
\subsection{Extend the BDI architecture to balance committment and opportunity seeking!}
\begin{itemize}
	\item Standard BDI: Beobachtung der Umwelt, Aktualisierung der Wissensbasis, Ermittle ausführbaren Optionen unter Verwendung der Beliefes und Intention, Filtere die aktuelle Intention aus der Wissensbasis + Desires + Intentionen, Ermittlere Plan, Führe Plan aus
	\item Problem: Agent verfolgt solange aktuelle Intention bis er glaubt diese erreicht zu haben (Blind Commitment)
	\item Lösungen:
	\begin{itemize}
		\item Single-Mindes Commitment: Agent verfolgt solange Intention bis er diese erreicht hat oder die Intention nicht mehr erreicht werden kann (Wie vorher nur für jeden Schritt im Plan wird überprüft ob nach der neuen Beobachtung das Zeil noch immer erreicht werden kann; falls nicht ermittlere neuen Plan)
		\item Open-minded Commitment: Agent verfolgt solange Intention wie er glaubt das diese noch möglich ist ???
	\end{itemize}
	\item Problem: Commmitments brauchen viel Rechenzeit (ständige neu Ermittelung usw)
\end{itemize}
\subsection{What is a plan and how are those developed, present a simple algorithm and describe its characteristics!}
\begin{itemize}
	\item generiert ein Plan (Folge von Aktion)
	\item Eingabe: Startzustand + Zielzustand, jeweils mit  Eigenschaften die in dem Zustand geleten
	\item Gesucht: Folge von Aktionen (Spezifiziert durch Name, Vorbedingungen und Nachbedinungen) welche vom Startzustand in den Zielzustand überführen
	\item Es muss gelten: Die Folge der Aktionen behindern sich nicht gegenseitig d.h. wenn Plan A,B,C darf A die Ausführung von B,C nicht behindern (Vorbedingungen und Nachbedingungen müssen übereinstimmen)
	\item Theorie: Ordnungsrelation für Aktionen $A \prec B$ (A muss vor B ausgeführt werden ($TakeCofee \prec DrinkCoffe$)), kausale Ordnung für Relationen $A \rightarrow B$ (Ausführung von A macht die Vorbedingungen von B wahr)
	\item Plan-Eigenschaften: TODO
	\item POP-Algorithmus:
	\begin{itemize}
		\item Start-Plan: Start $\rightarrow$ Ziels
		\item Rückwärts auflösen von offenen Bedingungen (passende Aktion wählen)
		\item Schrittweise Berücksichtigung der Ordnungsrelation und kausalen Ordnung
		\item wenn Konflikt d.h kausale Ordnung verletzt: Demotion (Konflikt-Aktion vorher ausführen) oder Promotion (Konflikt-Aktion hinterher ausführen)
		\item wenn dadurch wieder Konflikt $\rightarrow$ Backtracking
	\end{itemize}
	\begin{itemize}
		\item 
	\end{itemize}
\end{itemize}
%TODO What is a plan and how are those developed, present a simple algorithm and describe its characteristics!
\subsection{Different types of committment, what can we be committed to?}
\begin{itemize}
	\item BDI-Agent
	\item Situation: Agent hat Plan generiert
	\item Commitment beschreiben Arten von der Abarbeitung des Plans
	\item Closed-Minded-Commitment (Standard): Agent generiert Plan und führt diesen aus (Problem: ggf kann Intention eigentlich nicht mehr erreicht werden während der Abarbeitung)
	\item Single-Minded-Commitment: Agent führt Plan schrittweise aus, nach jeden Schritt B aktualisieren und Überprüfung ob I noch erreicht werden kann (Agent führt Plan solange aus bis dieser abgearbeitet wurde oder das aktuelle I nicht mehr erreicht werden kann)
	\item Open-Minded-Commitment: Agent führt Plan schrittweise aus, nach jedem Schritt B,D,I aktualisieren und Überprüfung ob I noch durch Plan erreicht wird falls nicht: neuen Plan für neus I
\end{itemize}
